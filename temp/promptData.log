Models:
// File name: cartModel
// File name with extension: cartModel.js
// Full path: E:\cloud_ShubhamJadhav\model\cartModel.js
// Directory: E:\cloud_ShubhamJadhav\model

const { sql, poolPromise } = require("../db/connect");

async function getAllCartItemsSql() {
  const pool = await poolPromise;
  const { recordset } = await pool.request().query("SELECT * FROM Cart_item");
  return recordset;
}

async function createCartItemsSql(
  cart_quantity,
  cart_id,
  product_id,
  purchased = "NO"
) {
  const pool = await poolPromise;
  const date = new Date().toISOString().split("T")[0];

  await pool
    .request()
    .input("cart_quantity", sql.Int, cart_quantity)
    .input("date_added", sql.Date, date)
    .input("cart_id", sql.VarChar(7), cart_id)
    .input("product_id", sql.VarChar(10), product_id)
    .input("purchased", sql.VarChar(10), purchased).query(`
      INSERT INTO Cart_item (cart_quantity, date_added, cart_id, product_id, purchased)
      VALUES (@cart_quantity, @date_added, @cart_id, @product_id, @purchased)
    `);

  return { cart_quantity, cart_id, product_id, purchased };
}

async function getSingleCartItemSql(cart_id) {
  const pool = await poolPromise;
  const query = `
    SELECT p.product_name, p.product_company, c.cart_quantity, p.cost, p.image, p.color,
           c.product_id, c.cart_id
    FROM Product p
    JOIN Cart_item c ON p.product_id = c.product_id
    WHERE c.cart_id = @cart_id AND c.purchased = 'NO'
  `;
  const { recordset } = await pool
    .request()
    .input("cart_id", sql.VarChar(7), cart_id)
    .query(query);
  return recordset;
}

async function updateCartSql(cart_id, cart_quantity, product_id) {
  const pool = await poolPromise;
  const { rowsAffected } = await pool
    .request()
    .input("cart_id", sql.VarChar(7), cart_id)
    .input("cart_quantity", sql.Int, cart_quantity)
    .input("product_id", sql.VarChar(10), product_id)
    .query(
      "UPDATE Cart_item SET cart_quantity = @cart_quantity WHERE cart_id = @cart_id AND product_id = @product_id"
    );
  return rowsAffected;
}

async function deleteCartItemSql(cart_id, product_id) {
  const pool = await poolPromise;
  const { rowsAffected } = await pool
    .request()
    .input("cart_id", sql.VarChar(7), cart_id)
    .input("product_id", sql.VarChar(10), product_id)
    .query(
      "DELETE FROM Cart_item WHERE cart_id = @cart_id AND product_id = @product_id"
    );
  return rowsAffected;
}

/*
 * createCartSql(cartIdOverride?)
 * Creates a new cart row and returns the cart_id.
 * If cartIdOverride is provided it will try to insert it; otherwise a unique id is generated.
 * Retries a few times on collision.
 /
async function createCartSql(cartIdOverride) {
  const pool = await poolPromise;
  const uid = new ShortUniqueId({ length: 7 });
  const maxAttempts = 6;
  let attempt = 0;

  while (attempt < maxAttempts) {
    const cart_id = cartIdOverride || uid.rnd(); // either override or generate
    try {
      // Parameterized insert with existence check to avoid constraint exceptions
      await pool.request().input("cart_id", sql.VarChar(7), cart_id).query(`
          IF NOT EXISTS (SELECT 1 FROM Cart WHERE cart_id = @cart_id)
            INSERT INTO Cart (cart_id) VALUES (@cart_id);
        `);

      // Confirm insertion
      const { recordset } = await pool
        .request()
        .input("cart_id", sql.VarChar(7), cart_id)
        .query("SELECT cart_id FROM Cart WHERE cart_id = @cart_id");

      if (recordset && recordset.length) {
        return cart_id;
      }

      // If not inserted, loop to try again
      attempt++;
      cartIdOverride = null; // force generation next try
    } catch (err) {
      // If unique constraint / primary key error, retry with a new id
      if (/unique|primary|violation/i.test(err.message)) {
        attempt++;
        cartIdOverride = null;
        continue;
      }
      // Unhandled error -> rethrow
      throw err;
    }
  }

  throw new Error("Unable to generate unique cart_id after multiple attempts.");
}

/
 * getCartByIdSql(cart_id)
 * Returns cart row if exists.
 /
async function getCartByIdSql(cart_id) {
  const pool = await poolPromise;
  const { recordset } = await pool
    .request()
    .input("cart_id", sql.VarChar(7), cart_id)
    .query("SELECT * FROM Cart WHERE cart_id = @cart_id");
  return recordset;
}
*/

module.exports = {
  getAllCartItemsSql,
  createCartItemsSql,
  getSingleCartItemSql,
  updateCartSql,
  deleteCartItemSql
  /*createCartSql,
  getCartByIdSql, */
};
// File name: customerModel
// File name with extension: customerModel.js
// Full path: E:\cloud_ShubhamJadhav\model\customerModel.js
// Directory: E:\cloud_ShubhamJadhav\model

const { sql, poolPromise } = require("../db/connect");
const ShortUniqueId = require("short-unique-id");
const bcrypt = require("bcryptjs");

async function getCustomer() {
  const pool = await poolPromise;
  const { recordset } = await pool.request().query("SELECT * FROM Customer");
  return recordset;
}

async function emailAlreadyExists(email) {
  const pool = await poolPromise;
  const { recordset } = await pool
    .request()
    .input("email", sql.VarChar(50), email)
    .query("SELECT email FROM Customer WHERE email = @email");
  return recordset.length > 0;
}

async function registerUserFunc({
  name,
  email,
  password,
  address,
  pincode,
  phone_number,
  role = "user"
}) {
  const pool = await poolPromise;
  const uid = new ShortUniqueId({ length: 6 });
  const customer_id = uid.rnd();
  const hashedPwd = await bcrypt.hash(password, 10);

  // ✅ Ensure cart exists or create one
  let cart_id;
  const existingCart = await pool
    .request()
    .query("SELECT TOP 1 cart_id FROM Cart ORDER BY NEWID()");
  if (existingCart.recordset.length === 0) {
    cart_id = uid.rnd();
    await pool
      .request()
      .input("cart_id", sql.VarChar(7), cart_id)
      .query("INSERT INTO Cart (cart_id) VALUES (@cart_id)");
  } else {
    cart_id = uid.rnd();
    await pool
      .request()
      .input("cart_id", sql.VarChar(7), cart_id)
      .query("INSERT INTO Cart (cart_id) VALUES (@cart_id)");
  }

  // ✅ Insert Customer
  await pool
    .request()
    .input("customer_id", sql.VarChar(7), customer_id)
    .input("name", sql.NVarChar(50), name)
    .input("email", sql.NVarChar(50), email)
    .input("password", sql.NVarChar(255), hashedPwd)
    .input("address", sql.NVarChar(sql.MAX), address)
    .input("pincode", sql.Int, pincode)
    .input("phone_number", sql.NVarChar(15), phone_number)
    .input("cart_id", sql.VarChar(7), cart_id)
    .input("role", sql.NVarChar(10), role).query(`
      INSERT INTO Customer (customer_id, name, email, password, address, pincode, phone_number, cart_id, role)
      VALUES (@customer_id, @name, @email, @password, @address, @pincode, @phone_number, @cart_id, @role)
    `);

  return {
    customer_id,
    cart_id,
    email,
    name,
    role,
    // ⚠ Safe only in development mode — do not expose full hash in production
    ...(process.env.NODE_ENV !== "production"
      ? {
          password_debug: password,
          password_hash_preview: hashedPwd.slice(0, 15) + "..."
        }
      : {})
  };
}

async function loginUserFunc(email) {
  const pool = await poolPromise;
  const { recordset } = await pool
    .request()
    .input("email", sql.VarChar(50), email)
    .query("SELECT * FROM Customer WHERE email = @email");
  return recordset[0];
}

module.exports = {
  getCustomer,
  emailAlreadyExists,
  registerUserFunc,
  loginUserFunc
};
// File name: paymentModel
// File name with extension: paymentModel.js
// Full path: E:\cloud_ShubhamJadhav\model\paymentModel.js
// Directory: E:\cloud_ShubhamJadhav\model

const { sql, poolPromise } = require("../db/connect");
const ShortUniqueId = require("short-unique-id");

async function getAllpaymentsSql() {
  const pool = await poolPromise;
  const payments = (await pool.request().query("SELECT * FROM Payment"))
    .recordset;
  const enriched = [];

  for (const p of payments) {
    const [{ names } = {}] = (
      await pool
        .request()
        .input("cart_id", sql.VarChar(7), p.cart_id)
        .input("payment_id", sql.VarChar(10), p.payment_id)
        .query(`SELECT STRING_AGG(product_name, ', ') AS names
              FROM Product WHERE product_id IN (
                SELECT product_id FROM Cart_item
                WHERE cart_id=@cart_id AND purchased=@payment_id)`)
    ).recordset;

    const [{ num } = {}] = (
      await pool
        .request()
        .input("cart_id", sql.VarChar(7), p.cart_id)
        .input("payment_id", sql.VarChar(10), p.payment_id)
        .query(`SELECT SUM(cart_quantity) AS num
              FROM Cart_item WHERE cart_id=@cart_id AND purchased=@payment_id`)
    ).recordset;

    const [{ name, address } = {}] = (
      await pool
        .request()
        .input("customer_id", sql.VarChar(7), p.customer_id)
        .query(
          "SELECT name,address FROM Customer WHERE customer_id=@customer_id"
        )
    ).recordset;

    enriched.push({
      ...p,
      product_names: names || "",
      total_items: num || 0,
      customer_name: name || "",
      address: address || ""
    });
  }
  return enriched;
}

async function createPaymentSql(
  payment_type,
  customer_id,
  cart_id,
  total_amount,
  product_ids = ""
) {
  const pool = await poolPromise;
  const payment_id = new ShortUniqueId({ length: 7 }).rnd();
  const date = new Date().toISOString().split("T")[0];

  if (isNaN(total_amount)) {
    throw new Error(`Invalid total_amount provided: ${total_amount}`);
  }

  // Insert Payment record
  await pool
    .request()
    .input("payment_id", sql.VarChar(10), payment_id)
    .input("payment_date", sql.Date, date)
    .input("payment_type", sql.VarChar(20), payment_type)
    .input("customer_id", sql.VarChar(7), customer_id)
    .input("cart_id", sql.VarChar(7), cart_id)
    .input("total_amount", sql.Int, total_amount).query(`
      INSERT INTO Payment 
      (payment_id, payment_date, payment_type, customer_id, cart_id, total_amount)
      VALUES (@payment_id, @payment_date, @payment_type, @customer_id, @cart_id, @total_amount)
    `);

  // Update Cart_item as purchased
  await pool
    .request()
    .input("cart_id", sql.VarChar(7), cart_id)
    .input("payment_id", sql.VarChar(10), payment_id)
    .query("UPDATE Cart_item SET purchased=@payment_id WHERE cart_id=@cart_id");

  return {
    payment_id,
    payment_date: date,
    total_amount
  };
}

async function getSinglePaymentSql(cart_id) {
  const pool = await poolPromise;
  const { recordset } = await pool
    .request()
    .input("cart_id", sql.VarChar(7), cart_id)
    .query("SELECT * FROM Payment WHERE cart_id=@cart_id");
  return recordset;
}

module.exports = { getAllpaymentsSql, createPaymentSql, getSinglePaymentSql };
// File name: productsModel
// File name with extension: productsModel.js
// Full path: E:\cloud_ShubhamJadhav\model\productsModel.js
// Directory: E:\cloud_ShubhamJadhav\model

const { sql, poolPromise } = require("../db/connect");
const ShortUniqueId = require("short-unique-id");

async function getAllProductsSql(filter = "") {
  const pool = await poolPromise;
  const { recordset } = await pool
    .request()
    .query(`SELECT * FROM Product ${filter}`);
  return recordset;
}

async function createProductSql({
  product_name,
  product_company,
  color,
  size,
  gender,
  cost,
  quantity,
  image
}) {
  const pool = await poolPromise;
  const uid = new ShortUniqueId({ length: 6 });
  const product_id = uid.rnd();

  // Validate inputs
  if (!product_name || !product_company || !cost || !quantity) {
    throw new Error("Missing required fields for product creation.");
  }

  // SQL Insert with strict parameterization
  const query = `
    INSERT INTO Product (
      product_id, product_name, product_company, color, size, gender, cost, quantity, image
    )
    VALUES (
      @product_id, @product_name, @product_company, @color, @size, @gender, @cost, @quantity, @image
    )
  `;

  await pool
    .request()
    .input("product_id", sql.VarChar(10), product_id)
    .input("product_name", sql.NVarChar(50), product_name)
    .input("product_company", sql.NVarChar(50), product_company)
    .input("color", sql.NVarChar(20), color || null)
    .input("size", sql.Int, size || null)
    .input("gender", sql.Char(1), gender || "U")
    .input("cost", sql.Int, cost)
    .input("quantity", sql.Int, quantity)
    .input("image", sql.NVarChar(sql.MAX), image || null)
    .query(query);

  return {
    success: true,
    product_id,
    message: "Product created successfully."
  };
}

async function getSingleProductsSql(id) {
  const pool = await poolPromise;
  const { recordset } = await pool
    .request()
    .input("id", sql.VarChar(10), id)
    .query("SELECT * FROM Product WHERE product_id = @id");
  return recordset;
}

async function deleteProductSql(id) {
  const pool = await poolPromise;
  await pool
    .request()
    .input("id", sql.VarChar(10), id)
    .query("DELETE FROM Product WHERE product_id = @id");
  return { deleted: true, product_id: id };
}

async function updateProductSql(id, updates) {
  const pool = await poolPromise;
  await pool
    .request()
    .query(`UPDATE Product SET ${updates} WHERE product_id = '${id}'`);
  return { updated: true, product_id: id };
}

module.exports = {
  getAllProductsSql,
  createProductSql,
  getSingleProductsSql,
  deleteProductSql,
  updateProductSql
};

Controllers:
// File name: cartController
// File name with extension: cartController.js
// Full path: E:\cloud_ShubhamJadhav\controllers\cartController.js
// Directory: E:\cloud_ShubhamJadhav\controllers

const asyncHandler = require("express-async-handler");
const {
  getAllCartItemsSql,
  createCartItemsSql,
  getSingleCartItemSql,
  updateCartSql,
  deleteCartItemSql
  /* createCartSql,
  getCartByIdSql */
} = require("../model/cartModel");

exports.getAllCartItems = asyncHandler(async (req, res) => {
  const items = await getAllCartItemsSql();
  res.status(200).json({ success: true, count: items.length, data: items });
});

exports.createCartItem = asyncHandler(async (req, res) => {
  const { cart_quantity, cart_id, product_id, purchased } = req.body;
  if (!cart_id || !product_id || !cart_quantity)
    return res.status(400).json({ success: false, msg: "Missing fields" });

  const result = await createCartItemsSql(
    cart_quantity,
    cart_id,
    product_id,
    purchased
  );
  res.status(201).json({ success: true, msg: "Cart item added", data: result });
});

exports.getSingleCart = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const data = await getSingleCartItemSql(id);
  if (data.length === 0)
    return res.status(404).json({ success: false, msg: "Cart not found" });
  res.status(200).json({ success: true, data });
});

exports.updateCart = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { cart_quantity, product_id } = req.body;
  const affected = await updateCartSql(id, cart_quantity, product_id);
  if (affected[0] === 0)
    return res.status(404).json({ success: false, msg: "Cart item not found" });
  res.status(200).json({ success: true, msg: "Cart updated" });
});

exports.deleteCartItem = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { product_id } = req.body;
  const deleted = await deleteCartItemSql(id, product_id);
  if (deleted[0] === 0)
    return res.status(404).json({ success: false, msg: "Cart item not found" });
  res.status(200).json({ success: true, msg: "Cart item deleted" });
});

/*
exports.createCart = asyncHandler(async (req, res) => {
  // optional: allow client to suggest a cart_id (not recommended for public API)
  const suggested = req.body && req.body.cart_id ? req.body.cart_id : undefined;
  const cart_id = await createCartSql(suggested);
  res.status(201).json({ success: true, cart_id, msg: "Cart created" });
});

exports.getCartById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const cart = await getCartByIdSql(id);
  if (!cart || cart.length === 0) {
    return res.status(404).json({ success: false, msg: "Cart not found" });
  }
  res.status(200).json({ success: true, data: cart[0] });
});
*/
// File name: customerController
// File name with extension: customerController.js
// Full path: E:\cloud_ShubhamJadhav\controllers\customerController.js
// Directory: E:\cloud_ShubhamJadhav\controllers

const asyncHandler = require("express-async-handler");
const bcrypt = require("bcryptjs");
const { createJWT, attachCookiesToResponse } = require("../utils/jwt");
const {
  getCustomer,
  emailAlreadyExists,
  registerUserFunc,
  loginUserFunc
} = require("../model/customerModel");

exports.getAllCustomers = asyncHandler(async (req, res) => {
  const customers = await getCustomer();
  res
    .status(200)
    .json({ success: true, count: customers.length, data: customers });
});

exports.register = asyncHandler(async (req, res) => {
  const { name, email, password, address, pincode, phone_number, role } =
    req.body;

  if (!name || !email || !password)
    return res
      .status(400)
      .json({ success: false, msg: "Required fields missing" });

  const exists = await emailAlreadyExists(email);
  if (exists)
    return res
      .status(400)
      .json({ success: false, msg: "Email already registered" });

  const user = await registerUserFunc({
    name,
    email,
    password,
    address,
    pincode,
    phone_number,
    role
  });

  const tokenPayload = { userId: user.customer_id, role: role || "user" };
  const token = createJWT(tokenPayload);

  res.status(201).json({
    success: true,
    msg: "User registered successfully",
    token,
    data: { ...user, name, email, role }
  });
});

exports.login = asyncHandler(async (req, res) => {
  const { email, password } = req.body;
  if (!email || !password)
    return res
      .status(400)
      .json({ success: false, msg: "Email and password required" });

  const user = await loginUserFunc(email);
  if (!user)
    return res.status(401).json({ success: false, msg: "Invalid credentials" });

  const validPwd = await bcrypt.compare(password, user.password);
  if (!validPwd)
    return res.status(401).json({ success: false, msg: "Invalid credentials" });

  const tokenPayload = { userId: user.customer_id, role: user.role };
  attachCookiesToResponse(res, tokenPayload);

  res.status(200).json({
    success: true,
    msg: "Login successful",
    user: { id: user.customer_id, name: user.name, role: user.role }
  });
});
// File name: paymentController
// File name with extension: paymentController.js
// Full path: E:\cloud_ShubhamJadhav\controllers\paymentController.js
// Directory: E:\cloud_ShubhamJadhav\controllers

const asyncHandler = require("express-async-handler");
const {
  getAllpaymentsSql,
  createPaymentSql,
  getSinglePaymentSql
} = require("../model/paymentModel");

exports.getAllPayments = asyncHandler(async (req, res) => {
  const payments = await getAllpaymentsSql();
  res
    .status(200)
    .json({ success: true, count: payments.length, data: payments });
});

exports.createPayment = asyncHandler(async (req, res) => {
  const { payment_type, customer_id, cart_id, total_amount } = req.body;
  if (!payment_type || !customer_id || !cart_id || !total_amount)
    return res
      .status(400)
      .json({ success: false, msg: "Missing payment data" });

  const payment = await createPaymentSql(
    payment_type,
    customer_id,
    cart_id,
    total_amount
  );
  res
    .status(201)
    .json({ success: true, msg: "Payment created", data: payment });
});

exports.getSinglePayment = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const payment = await getSinglePaymentSql(id);
  if (payment.length === 0)
    return res.status(404).json({ success: false, msg: "Payment not found" });
  res.status(200).json({ success: true, data: payment });
});
// File name: productsController
// File name with extension: productsController.js
// Full path: E:\cloud_ShubhamJadhav\controllers\productsController.js
// Directory: E:\cloud_ShubhamJadhav\controllers

const asyncHandler = require("express-async-handler");
const {
  getAllProductsSql,
  createProductSql,
  getSingleProductsSql,
  deleteProductSql,
  updateProductSql
} = require("../model/productsModel");

exports.getAllProducts = asyncHandler(async (req, res) => {
  const filters = [];
  const { name, company, color, size, gender, cost } = req.query;

  if (name) filters.push(`product_name = '${name}'`);
  if (company) filters.push(`product_company = '${company}'`);
  if (color) filters.push(`color = '${color}'`);
  if (size) filters.push(`size = ${size}`);
  if (gender) filters.push(`gender = '${gender}'`);
  if (cost) filters.push(`cost <= ${cost}`);

  const filterString = filters.length ? "WHERE " + filters.join(" AND ") : "";
  const products = await getAllProductsSql(filterString);

  res
    .status(200)
    .json({ success: true, count: products.length, data: products });
});

exports.createProduct = asyncHandler(async (req, res) => {
  const data = await createProductSql(req.body);
  res.status(201).json({ success: true, msg: "Product created", data });
});

exports.getSingleProduct = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const product = await getSingleProductsSql(id);
  if (product.length === 0)
    return res.status(404).json({ success: false, msg: "Product not found" });
  res.status(200).json({ success: true, data: product });
});

exports.updateProduct = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const productExists = await getSingleProductsSql(id);
  if (productExists.length === 0)
    return res.status(404).json({ success: false, msg: "Product not found" });

  const updates = Object.entries(req.body)
    .map(([k, v]) => `${k}='${v}'`)
    .join(", ");

  await updateProductSql(id, updates);
  const updated = await getSingleProductsSql(id);
  res
    .status(200)
    .json({ success: true, msg: "Product updated", data: updated });
});

exports.deleteProduct = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const existing = await getSingleProductsSql(id);
  if (existing.length === 0)
    return res.status(404).json({ success: false, msg: "Product not found" });

  await deleteProductSql(id);
  res.status(200).json({ success: true, msg: "Product deleted" });
});
// File name: uploadsController
// File name with extension: uploadsController.js
// Full path: E:\cloud_ShubhamJadhav\controllers\uploadsController.js
// Directory: E:\cloud_ShubhamJadhav\controllers

const asyncHandler = require("express-async-handler");
const path = require("path");

exports.uploadProductImage = asyncHandler(async (req, res) => {
  if (!req.files || !req.files.image)
    return res
      .status(400)
      .json({ success: false, msg: "Please upload an image" });

  const productImage = req.files.image;

  if (!productImage.mimetype.startsWith("image"))
    return res
      .status(400)
      .json({ success: false, msg: "File must be an image" });

  if (productImage.size > 1024 * 1024)
    return res
      .status(400)
      .json({ success: false, msg: "Image must be under 1MB" });

  const imagePath = path.join(
    __dirname,
    "../public/uploads/",
    productImage.name
  );
  await productImage.mv(imagePath);

  res.status(201).json({
    success: true,
    msg: "Image uploaded",
    image: `${process.env.BASE_URL}/uploads/${productImage.name}`
  });
});

Routes:
// File name: cartRouter
// File name with extension: cartRouter.js
// Full path: E:\cloud_ShubhamJadhav\routes\cartRouter.js
// Directory: E:\cloud_ShubhamJadhav\routes

const express = require("express");
const router = express.Router();
const {
  getAllCartItems,
  createCartItem,
  getSingleCart,
  updateCart,
  deleteCartItem
  /* createCart,
  getCartById */
} = require("../controllers/cartController");

// create a cart (returns cart_id)
// router.post("/", createCart);

// optional: get cart record (metadata)
// router.get("/:id/meta", getCartById);

// cart item routes
router.route("/").get(getAllCartItems).post(createCartItem);
router.route("/:id").get(getSingleCart).patch(updateCart);
router.route("/delete/:id").patch(deleteCartItem);

module.exports = router;
// File name: customerRoute
// File name with extension: customerRoute.js
// Full path: E:\cloud_ShubhamJadhav\routes\customerRoute.js
// Directory: E:\cloud_ShubhamJadhav\routes

const express = require("express");
const router = express.Router();
const { getAllCustomers, register, login } = require("../controllers/customerController");

router.route("/").get(getAllCustomers);
router.route("/register").post(register);
router.route("/login").post(login);

module.exports = router;
// File name: paymentRouter
// File name with extension: paymentRouter.js
// Full path: E:\cloud_ShubhamJadhav\routes\paymentRouter.js
// Directory: E:\cloud_ShubhamJadhav\routes

const express = require("express");
const router = express.Router();
const {
  getAllPayments,
  createPayment,
  getSinglePayment
} = require("../controllers/paymentController");

router.route("/").get(getAllPayments).post(createPayment);
router.route("/:id").get(getSinglePayment);

module.exports = router;
// File name: productRoute
// File name with extension: productRoute.js
// Full path: E:\cloud_ShubhamJadhav\routes\productRoute.js
// Directory: E:\cloud_ShubhamJadhav\routes

const express = require("express");
const router = express.Router();
const {
  createProduct,
  getAllProducts,
  getSingleProduct,
  deleteProduct,
  updateProduct
} = require("../controllers/productsController");
const { uploadProductImage } = require("../controllers/uploadsController");

router.route("/").get(getAllProducts).post(createProduct);
router
  .route("/:id")
  .get(getSingleProduct)
  .patch(updateProduct)
  .delete(deleteProduct);
router.route("/uploads").post(uploadProductImage);

module.exports = router;

API Entrypoint app.js:
// =========================
// File: app.js
// Path: E:\cloud_ShubhamJadhav\app.js
// =========================

require("dotenv").config();
const express = require("express");
const cors = require("cors");
const cookieParser = require("cookie-parser");
const fileUpload = require("express-fileupload");
const errorHandler = require("./middleware/error-handler");
const { StatusCodes } = require("http-status-codes"); // ✅ for standardized HTTP codes

const app = express();

// ----------------------------------------------------
// 🧠 Debugging & Performance Hooks (NEW)
// ----------------------------------------------------
const DEBUG = process.env.DEBUG_MODE === "true"; // controlled via .env
if (DEBUG) {
  console.log(
    "[🪶 DEBUG MODE ON] Express routes and middleware tracing enabled."
  );
  const morgan = require("morgan"); // no extra package—comes with nodemon dev use
  app.use(morgan("dev")); // log HTTP requests in console
}

// ----------------------------------------------------
// 🧪 Health Check Endpoint (NEW)
// ----------------------------------------------------
app.get("/api/health", (req, res) => {
  res.status(StatusCodes.OK).json({
    app: "Footware Management Software",
    status: "running",
    time: new Date(),
    debugMode: DEBUG
  });
});

// ----------------------------------------------------
// Middleware
// ----------------------------------------------------
app.use(express.json());
app.use(cors());
app.use(cookieParser());
app.use(express.static("./public"));
app.use(fileUpload({ useTempFiles: true }));

// ----------------------------------------------------
// Routers
// ----------------------------------------------------
const customerRouter = require("./routes/customerRoute");
const productRouter = require("./routes/productRoute");
const cartRouter = require("./routes/cartRouter");
const paymentRouter = require("./routes/paymentRouter");

app.use("/api/v1/customer", customerRouter);
app.use("/api/v1/products", productRouter);
app.use("/api/v1/cart", cartRouter);
app.use("/api/v1/payment", paymentRouter);

// ----------------------------------------------------
// 🧭 Route Debug Utility (NEW)
// ----------------------------------------------------
if (DEBUG) {
  app.get("/api/debug/routes", (req, res) => {
    const routes = [];
    app._router.stack.forEach((r) => {
      if (r.route && r.route.path) {
        routes.push({
          methods: Object.keys(r.route.methods).join(",").toUpperCase(),
          path: r.route.path
        });
      }
    });
    res.status(StatusCodes.OK).json({
      totalRoutes: routes.length,
      routes
    });
  });
}

// ----------------------------------------------------
// Fallback 404 Route
// ----------------------------------------------------
app.get("*", (req, res) => {
  res.status(StatusCodes.NOT_FOUND).json({
    status: 404,
    msg: "Route not found"
  });
});

// ----------------------------------------------------
// Error Middleware
// ----------------------------------------------------
app.use(errorHandler);

// ----------------------------------------------------
// Server Start
// ----------------------------------------------------
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`\n[✅] Server running on port ${PORT}\n`));

module.exports = app; // ✅ Required for test/debug scripts
SQL Server:
    -- Create Cart Table
    IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='Cart' AND xtype='U')
    BEGIN
        CREATE TABLE Cart (
            cart_id VARCHAR(7) PRIMARY KEY
        );
        PRINT '✓ Cart table created successfully.';
    END
    ELSE
    BEGIN
        PRINT 'ℹ Cart table already exists.';
    END

    -- Create Customer Table
    IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='Customer' AND xtype='U')
    BEGIN
        CREATE TABLE Customer (
            customer_id VARCHAR(7) PRIMARY KEY,
            name NVARCHAR(50) NOT NULL,
            email NVARCHAR(50) NOT NULL UNIQUE,
            password NVARCHAR(255) NOT NULL,
            address NVARCHAR(MAX) NOT NULL,
            pincode INT NOT NULL,
            phone_number NVARCHAR(15) NOT NULL,
            cart_id VARCHAR(7) NOT NULL,
            role NVARCHAR(10) DEFAULT 'user',
            FOREIGN KEY (cart_id) REFERENCES Cart(cart_id)
        );
        PRINT '✓ Customer table created successfully.';
    END
    ELSE
    BEGIN
        PRINT 'ℹ Customer table already exists.';
    END

    -- Create Product Table
    IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='Product' AND xtype='U')
    BEGIN
        CREATE TABLE Product (
            product_id VARCHAR(10) PRIMARY KEY,
            product_name NVARCHAR(50) NOT NULL,
            product_company NVARCHAR(50) NOT NULL,
            color NVARCHAR(20),
            size INT,
            gender CHAR(1),
            cost INT,
            quantity INT,
            image NVARCHAR(MAX)
        );
        PRINT '✓ Product table created successfully.';
    END
    ELSE
    BEGIN
        PRINT 'ℹ Product table already exists.';
    END

    -- Create Cart_item Table
    IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='Cart_item' AND xtype='U')
    BEGIN
        CREATE TABLE Cart_item (
            cart_id VARCHAR(7) NOT NULL,
            product_id VARCHAR(10) NOT NULL,
            cart_quantity INT NOT NULL,
            date_added DATE NOT NULL,
            purchased NVARCHAR(10) DEFAULT 'NO',
            PRIMARY KEY (cart_id, product_id),
            FOREIGN KEY (cart_id) REFERENCES Cart(cart_id),
            FOREIGN KEY (product_id) REFERENCES Product(product_id)
        );
        PRINT '✓ Cart_item table created successfully.';
    END
    ELSE
    BEGIN
        PRINT 'ℹ Cart_item table already exists.';
    END

    -- Create Payment Table
    IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='Payment' AND xtype='U')
    BEGIN
        CREATE TABLE Payment (
            payment_id VARCHAR(10) PRIMARY KEY,
            payment_date DATE NOT NULL,
            payment_type NVARCHAR(20),
            customer_id VARCHAR(7),
            cart_id VARCHAR(7),
            total_amount INT,
            FOREIGN KEY (customer_id) REFERENCES Customer(customer_id),
            FOREIGN KEY (cart_id) REFERENCES Cart(cart_id)
        );
        PRINT '✓ Payment table created successfully.';
    END
    ELSE
    BEGIN
        PRINT 'ℹ Payment table already exists.';
    END
.env file:
# ==============================
# 🌐 SERVER CONFIG
# ==============================
PORT=8065
NODE_ENV=development
BASE_URL=http://localhost:8065

# ==============================
# 🗄️ DATABASE (SQL Server)
# ==============================
DB_USER=DeveloperKunal
DB_PASSWORD=tech@123
DB_NAME=FootwareApp_Dev
DB_SERVER=GOD
DB_PORT=1433
DB_INSTANCE=SQLSERVEREXP22

# ==============================
# 🔐 JWT SECURITY
# ==============================
JWT_SECRET=ShubhamJadhav@Secure_Prod_Secret_Key_2025
JWT_LIFETIME=1h
REFRESH_SECRET=ShubhamJadhav@Refresh_Token_2025
REFRESH_LIFETIME=7d

~/client/.env file:
VITE_API_BASE_URL=/api/v1

Generate a ChatGPT Project Instructions prompt that is under 8,000 characters. which is easily understood by the ChatGPT Project section and static this code